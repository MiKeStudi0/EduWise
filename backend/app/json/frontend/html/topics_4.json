{
  "topic": {
    "id": 4,
    "roadmap_id": 1,
    "technology_id": 1,
    "module_id": 2,
    "slug": "html-dom-fundamentals",
    "title": "HTML DOM Fundamentals",
    "description": "The DOM is the browser's live object tree of an HTML document that JavaScript can read and modify.",
    "content": [
      {
        "type": "heading",
        "level": 1,
        "text": "What Is the DOM?"
      },
      {
        "type": "paragraph",
        "text": [
          {
            "value": "When a browser loads an HTML file it parses the markup and builds a "
          },
          {
            "value": "Document Object Model",
            "bold": true
          },
          {
            "value": " in memory. The DOM is not the HTML source file. It is a "
          },
          {
            "value": "live tree of objects",
            "bold": true
          },
          {
            "value": " where every element, text node, comment, and attribute becomes a JavaScript-accessible object. Changes to the DOM instantly update what the user sees without reloading the page. The DOM standard is maintained by the "
          },
          {
            "value": "WHATWG DOM Living Standard",
            "link": "https://dom.spec.whatwg.org/"
          },
          {
            "value": " and documented in full at "
          },
          {
            "value": "MDN: Introduction to the DOM",
            "link": "https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction"
          },
          {
            "value": "."
          }
        ]
      },
      {
        "type": "table",
        "headers": [
          "Node Type",
          "nodeType Value",
          "Example",
          "Description"
        ],
        "rows": [
          [
            "Element node",
            "1",
            "<p>, <div>, <h1>",
            "Every HTML element in the document"
          ],
          [
            "Text node",
            "3",
            "Hello World",
            "The text content inside an element"
          ],
          [
            "Comment node",
            "8",
            "<!-- note -->",
            "HTML comments in the source"
          ],
          [
            "Document node",
            "9",
            "document",
            "The root node representing the whole document"
          ],
          [
            "Attribute node",
            "2",
            "class=\"card\"",
            "Attributes on elements (accessed via element, not tree)"
          ]
        ]
      },
      {
        "type": "callout",
        "variant": "info",
        "title": "DOM vs HTML Source",
        "text": "The DOM and the HTML source file are not the same thing. The browser fixes malformed HTML when building the DOM, JavaScript can add nodes that were never in the source, and the DOM reflects the current live state of the page at any moment."
      }
    ],
    "examples": [
      {
        "title": "Exploring the DOM Tree: Nodes, Parents, Children, and Siblings",
        "description": "This example builds a visible page structure and then uses JavaScript to walk the DOM tree using parent, child, and sibling relationships. Understanding tree traversal is the foundation for every DOM operation that selects or modifies elements without hardcoded IDs.",
        "code_snippet": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>DOM Tree Explorer</title>\n  <style>\n    body { font-family: sans-serif; max-width: 700px; margin: 2rem auto; padding: 0 1rem; }\n    .highlight { background: #fef9c3; outline: 2px solid #ca8a04; }\n    #output { background: #0f172a; color: #e2e8f0; padding: 1rem;\n              border-radius: 8px; font-family: monospace; font-size: 0.85rem;\n              margin-top: 1rem; white-space: pre; }\n    button { padding: 0.4rem 0.9rem; border-radius: 6px; border: 1px solid #d1d5db;\n             cursor: pointer; margin-right: 0.5rem; margin-bottom: 0.5rem; }\n  </style>\n</head>\n<body>\n\n  <h1>DOM Tree Explorer</h1>\n\n  <section id=\"team\">\n    <h2>Engineering Team</h2>\n    <ul id=\"member-list\">\n      <li class=\"member\" data-role=\"lead\">Priya Sharma</li>\n      <li class=\"member\" data-role=\"senior\">Rahul Gupta</li>\n      <li class=\"member\" data-role=\"junior\">Anjali Mehta</li>\n    </ul>\n  </section>\n\n  <div>\n    <button id=\"btn-parent\">parentElement</button>\n    <button id=\"btn-children\">children</button>\n    <button id=\"btn-first\">firstElementChild</button>\n    <button id=\"btn-last\">lastElementChild</button>\n    <button id=\"btn-next\">nextElementSibling</button>\n    <button id=\"btn-prev\">previousElementSibling</button>\n    <button id=\"btn-nodes\">childNodes (all)</button>\n  </div>\n\n  <div id=\"output\">Click a button to inspect the DOM tree...</div>\n\n  <script>\n    const list   = document.getElementById('member-list');\n    const output = document.getElementById('output');\n\n    function log(label, node) {\n      if (!node) { output.textContent = label + ': null'; return; }\n      const info = node.nodeType === 1\n        ? `<${node.tagName.toLowerCase()}> \"${node.textContent.trim()}\"`\n        : node.nodeType === 3\n          ? `TextNode: \"${node.textContent.trim() || '(whitespace)'}\" `\n          : `NodeType ${node.nodeType}`;\n      output.textContent = `${label}:\\n  ${info}`;\n    }\n\n    // parentElement: the immediate element parent\n    document.getElementById('btn-parent').onclick = () => {\n      log('list.parentElement', list.parentElement);\n      // returns <section id=\"team\">\n    };\n\n    // children: live HTMLCollection of element children only (no text nodes)\n    document.getElementById('btn-children').onclick = () => {\n      const names = [...list.children].map(li => li.textContent.trim());\n      output.textContent = `list.children (${list.children.length}):\\n  ${names.join('\\n  ')}`;\n    };\n\n    // firstElementChild / lastElementChild: element nodes only\n    document.getElementById('btn-first').onclick = () =>\n      log('list.firstElementChild', list.firstElementChild);\n\n    document.getElementById('btn-last').onclick = () =>\n      log('list.lastElementChild', list.lastElementChild);\n\n    // nextElementSibling / previousElementSibling: adjacent element siblings\n    document.getElementById('btn-next').onclick = () => {\n      const second = list.children[1]; // Rahul Gupta\n      log('second-li.nextElementSibling', second.nextElementSibling);\n      // returns <li>Anjali Mehta</li>\n    };\n\n    document.getElementById('btn-prev').onclick = () => {\n      const second = list.children[1];\n      log('second-li.previousElementSibling', second.previousElementSibling);\n      // returns <li>Priya Sharma</li>\n    };\n\n    // childNodes: includes element nodes AND text nodes (whitespace included)\n    document.getElementById('btn-nodes').onclick = () => {\n      const nodes = [...list.childNodes];\n      const info  = nodes.map(n =>\n        n.nodeType === 1\n          ? `Element: <${n.tagName.toLowerCase()}> \"${n.textContent.trim()}\"`\n          : `Text:    \"${n.textContent.trim() || '(whitespace)'}\" `\n      ).join('\\n  ');\n      output.textContent = `list.childNodes (${nodes.length}):\\n  ${info}`;\n      // Shows 7 nodes: 3 li elements + 4 whitespace text nodes between them\n    };\n  </script>\n\n</body>\n</html>",
        "output": "Page renders an Engineering Team section with three list items and six inspector buttons. Clicking parentElement shows the section element. Clicking children shows the three member names. Clicking childNodes shows 7 nodes total: three li elements and four whitespace text nodes between them, demonstrating why childNodes count differs from children count. Each button updates the dark output panel with the result.",
        "images": null,
        "video_url": null
      },
      {
        "title": "DOM Selection, Inspection, and Manipulation",
        "description": "This example covers all major DOM selection methods and the most common manipulation operations: reading and writing text content, changing attributes, toggling classes, creating new nodes, inserting them, and removing them. These are the core operations behind every interactive web component.",
        "code_snippet": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>DOM Manipulation</title>\n  <style>\n    body { font-family: sans-serif; max-width: 700px; margin: 2rem auto; padding: 0 1rem; }\n    .card { border: 1px solid #e5e7eb; border-radius: 8px; padding: 1rem; margin-bottom: 0.75rem; }\n    .featured { border-color: #2563eb; background: #eff6ff; }\n    .badge { display:inline-block; background:#dbeafe; color:#1d4ed8;\n             padding:0.15rem 0.5rem; border-radius:999px; font-size:0.75rem; }\n    button { padding:0.4rem 0.8rem; border-radius:6px; border:1px solid #d1d5db;\n             cursor:pointer; margin: 0.25rem; }\n    #log { background:#0f172a; color:#86efac; padding:1rem; border-radius:8px;\n           font-family:monospace; font-size:0.8rem; margin-top:1rem;\n           min-height:60px; white-space:pre-wrap; }\n  </style>\n</head>\n<body>\n\n  <h1 id=\"page-title\">Product Catalogue</h1>\n\n  <div id=\"catalogue\">\n    <div class=\"card\" id=\"card-1\" data-product=\"laptop\">\n      <h3 class=\"card-title\">ThinkBook 14</h3>\n      <p class=\"card-price\">Rs 62,000</p>\n    </div>\n    <div class=\"card featured\" id=\"card-2\" data-product=\"phone\">\n      <h3 class=\"card-title\">Pixel 8a</h3>\n      <p class=\"card-price\">Rs 52,999</p>\n    </div>\n  </div>\n\n  <div>\n    <button id=\"btn-read\">Read Content</button>\n    <button id=\"btn-write\">Update Title</button>\n    <button id=\"btn-attr\">Toggle Featured</button>\n    <button id=\"btn-class\">Add Badge</button>\n    <button id=\"btn-create\">Add Card</button>\n    <button id=\"btn-remove\">Remove Last Card</button>\n    <button id=\"btn-query\">querySelectorAll</button>\n  </div>\n\n  <div id=\"log\">Click a button to see the operation...</div>\n\n  <script>\n    const catalogue = document.getElementById('catalogue');\n    const log       = document.getElementById('log');\n    const print     = msg => { log.textContent = msg; };\n\n\n    // ===== SELECTION METHODS =====\n\n    // getElementById: fastest, returns single element or null\n    const card1 = document.getElementById('card-1');\n\n    // querySelector: CSS selector, returns first match or null\n    const firstTitle = document.querySelector('.card-title');\n\n    // querySelectorAll: CSS selector, returns static NodeList\n    const allCards = document.querySelectorAll('.card');\n\n    // getElementsByClassName: live HTMLCollection\n    const byClass = document.getElementsByClassName('card');\n\n\n    // ===== READ CONTENT =====\n    document.getElementById('btn-read').onclick = () => {\n      const title = document.getElementById('page-title');\n\n      // textContent: all text, including hidden elements, no HTML tags\n      // innerHTML:   raw HTML string including child tags\n      // innerText:   only visible text, respects CSS display:none\n      print(\n        `textContent: \"${title.textContent}\"\\n` +\n        `innerHTML:   \"${title.innerHTML}\"\\n` +\n        `id attr:     \"${title.getAttribute('id')}\"\\n` +\n        `tagName:     \"${title.tagName}\"\\n` +\n        `card1 data:  \"${card1.dataset.product}\"`\n      );\n    };\n\n\n    // ===== WRITE CONTENT =====\n    document.getElementById('btn-write').onclick = () => {\n      const title = document.getElementById('page-title');\n      title.textContent = 'Updated Catalogue 2024';\n      // Use textContent to set plain text (safe, no XSS risk)\n      // Use innerHTML only when you intentionally need to insert HTML markup\n      print('Title updated via textContent.');\n    };\n\n\n    // ===== ATTRIBUTE MANIPULATION =====\n    document.getElementById('btn-attr').onclick = () => {\n      const card2 = document.getElementById('card-2');\n\n      // classList methods: add, remove, toggle, contains, replace\n      card2.classList.toggle('featured');\n\n      // getAttribute / setAttribute / removeAttribute\n      const hasFeatured = card2.classList.contains('featured');\n      print(`card-2 featured class: ${hasFeatured}\\nclassList: ${[...card2.classList].join(', ')}`);\n    };\n\n\n    // ===== ADD A BADGE VIA innerHTML =====\n    document.getElementById('btn-class').onclick = () => {\n      const title = card1.querySelector('.card-title');\n      // innerHTML is acceptable here: content is not user-supplied\n      title.innerHTML = 'ThinkBook 14 <span class=\"badge\">New</span>';\n      print('Badge added via innerHTML.');\n    };\n\n\n    // ===== CREATE AND INSERT A NEW NODE =====\n    document.getElementById('btn-create').onclick = () => {\n      // createElement: creates a detached element\n      const newCard  = document.createElement('div');\n      newCard.className = 'card';\n      newCard.id = `card-${Date.now()}`;\n\n      // createTextNode or textContent to set safe text\n      const heading = document.createElement('h3');\n      heading.className = 'card-title';\n      heading.textContent = 'Galaxy Tab S9';\n\n      const price = document.createElement('p');\n      price.className = 'card-price';\n      price.textContent = 'Rs 74,999';\n\n      // Append children to the new card\n      newCard.appendChild(heading);\n      newCard.appendChild(price);\n\n      // Insert the new card into the DOM\n      catalogue.appendChild(newCard);           // adds at the end\n      // catalogue.prepend(newCard);            // adds at the start\n      // card1.insertAdjacentElement('afterend', newCard); // after card-1\n\n      print(`Created and appended: ${newCard.id}`);\n    };\n\n\n    // ===== REMOVE A NODE =====\n    document.getElementById('btn-remove').onclick = () => {\n      const last = catalogue.lastElementChild;\n      if (last) {\n        const removed = last.id;\n        last.remove();           // modern: element removes itself\n        print(`Removed: ${removed}`);\n      } else {\n        print('No cards left to remove.');\n      }\n    };\n\n\n    // ===== querySelectorAll DEMO =====\n    document.getElementById('btn-query').onclick = () => {\n      // Returns a static NodeList, not live\n      const titles = document.querySelectorAll('#catalogue .card-title');\n      const names  = [...titles].map(t => t.textContent.trim()).join(', ');\n      print(`querySelectorAll('.card-title') found ${titles.length}:\\n${names}`);\n    };\n\n  </script>\n\n</body>\n</html>",
        "output": "Page renders a catalogue heading, two product cards (second with blue featured styling), and six action buttons. Read Content logs textContent, innerHTML, id attribute, tagName, and dataset value. Update Title changes the h1 text. Toggle Featured switches the blue styling on and off. Add Badge injects a New badge into the first card title. Add Card appends a third Galaxy Tab S9 card. Remove Last Card deletes the most recent card. querySelectorAll logs all current card titles with a count.",
        "images": null,
        "video_url": null
      }
    ],
    "image_banner_url": null,
    "images": null,
    "video_url": null,
    "when_to_use": [
      {
        "point": "When reading or modifying page content dynamically without a full page reload"
      },
      {
        "point": "When building interactive UI components that respond to user actions"
      },
      {
        "point": "When traversing element relationships to find siblings, parents, or children"
      }
    ],
    "when_to_avoid": [
      {
        "point": "Avoid frequent individual DOM updates in loops, batch with DocumentFragment instead"
      },
      {
        "point": "Avoid innerHTML with unsanitised user input as it creates XSS vulnerabilities"
      },
      {
        "point": "Avoid deep DOM traversal chains like parent.parent.children when an id selector works"
      }
    ],
    "what_it_solves": [
      {
        "1": "Static HTML alone cannot update content after the page loads without the DOM API."
      },
      {
        "2": "Without the DOM, JavaScript has no structured way to find, read, or change page elements."
      },
      {
        "3": "DOM tree relationships let code navigate complex structures without memorising every element ID."
      }
    ],
    "conceptual_understanding": [
      {
        "model": "The DOM is like a live organisation chart for a company. The document is the CEO at the top. Each department head is an element node. Each employee is a text or child element node. You can read who reports to whom, move people between departments, hire new employees, or fire existing ones, and the org chart updates instantly to reflect the changes."
      },
      {
        "model": "The difference between HTML source and the DOM is like the difference between a blueprint and the actual building. The blueprint is the original HTML file, static and unchanging on disk. The building is the DOM, constructed from the blueprint but then modified by workers over time. Renovations happen to the building, not to the blueprint stored in the archive."
      },
      {
        "model": "childNodes versus children is like counting everyone in a room versus counting only the adults. childNodes includes every node: element nodes, text nodes, and whitespace nodes. children counts only element nodes. The room looks the same but the count depends on who you include in the tally."
      }
    ],
    "common_mistakes": [
      {
        "mistake": "Confusing childNodes with children: childNodes returns all node types including whitespace text nodes between elements. children returns only element nodes. Looping over childNodes expecting only elements will process unexpected text nodes and cause errors or incorrect results."
      },
      {
        "mistake": "Using innerHTML with user-supplied data: Setting element.innerHTML = userInput directly injects raw HTML into the DOM. If the input contains a script tag or an event attribute like onerror, it executes in the user's browser, creating a cross-site scripting vulnerability. Always use textContent for plain text from user input."
      },
      {
        "mistake": "Querying the DOM before it is ready: Running document.getElementById or querySelector at the top of a script file before the HTML below it has been parsed returns null. Always place scripts at the end of body, or use the defer attribute on the script tag, or wrap code in DOMContentLoaded to ensure elements exist before selecting them."
      }
    ],
    "bonus_tips": [
      {
        "tip": "Use document.querySelector with any valid CSS selector to select elements with the same syntax you already know from CSS. For example: document.querySelector('section#team li.member[data-role=\"lead\"]') finds the lead member inside the team section in one call. This is often more precise and readable than chaining multiple DOM traversal calls."
      },
      {
        "tip": "When appending multiple new elements in a loop, use a DocumentFragment to batch all insertions into a single DOM update. Create the fragment with document.createDocumentFragment(), append all new nodes to it, then append the fragment to the DOM once. This triggers only one reflow instead of one per element, significantly improving performance for large lists."
      }
    ],
    "related_topics": [
      "HTML Elements Tags and Attributes",
      "HTML Semantic Elements",
      "JavaScript DOM Manipulation",
      "Browser DevTools",
      "JavaScript Events"
    ],
    "is_active": true,
    "order_index": 4,
    "created_at": null,
    "updated_at": null
  },
  "subtopics": [
    {
      "id": 1,
      "roadmap_id": 1,
      "technology_id": 1,
      "module_id": 2,
      "topic_id": 4,
      "slug": "dom-tree-and-node-relationships",
      "title": "DOM Tree and Node Relationships",
      "description": "The DOM tree is a hierarchy of nodes where every element, text, and comment has a defined position.",
      "content": [
        {
          "type": "paragraph",
          "text": [
            {
              "value": "The DOM tree starts at the "
            },
            {
              "value": "document",
              "highlight": true
            },
            {
              "value": " node, then the "
            },
            {
              "value": "html",
              "highlight": true
            },
            {
              "value": " element, then branches into "
            },
            {
              "value": "head",
              "highlight": true
            },
            {
              "value": " and "
            },
            {
              "value": "body",
              "highlight": true
            },
            {
              "value": ", and continues branching from there. Each node has a "
            },
            {
              "value": "parentNode",
              "highlight": true
            },
            {
              "value": ", zero or more "
            },
            {
              "value": "childNodes",
              "highlight": true
            },
            {
              "value": ", and optional "
            },
            {
              "value": "previousSibling",
              "highlight": true
            },
            {
              "value": " and "
            },
            {
              "value": "nextSibling",
              "highlight": true
            },
            {
              "value": " neighbours. The element-only variants ("
            },
            {
              "value": "parentElement",
              "highlight": true
            },
            {
              "value": ", "
            },
            {
              "value": "children",
              "highlight": true
            },
            {
              "value": ", "
            },
            {
              "value": "firstElementChild",
              "highlight": true
            },
            {
              "value": ") skip text and comment nodes, which is what most code needs. Full reference at "
            },
            {
              "value": "MDN: Node relationships",
              "link": "https://developer.mozilla.org/en-US/docs/Web/API/Node"
            },
            {
              "value": "."
            }
          ]
        },
        {
          "type": "table",
          "headers": [
            "Property",
            "Returns",
            "Includes Text Nodes?"
          ],
          "rows": [
            [
              "parentNode",
              "Parent node of any type",
              "Yes"
            ],
            [
              "parentElement",
              "Parent element node only",
              "No"
            ],
            [
              "childNodes",
              "All child nodes (NodeList)",
              "Yes"
            ],
            [
              "children",
              "Child element nodes only (HTMLCollection)",
              "No"
            ],
            [
              "firstChild",
              "First child node of any type",
              "Yes"
            ],
            [
              "firstElementChild",
              "First child element node",
              "No"
            ],
            [
              "lastChild",
              "Last child node of any type",
              "Yes"
            ],
            [
              "lastElementChild",
              "Last child element node",
              "No"
            ],
            [
              "nextSibling",
              "Next sibling node of any type",
              "Yes"
            ],
            [
              "nextElementSibling",
              "Next sibling element node",
              "No"
            ],
            [
              "previousSibling",
              "Previous sibling node of any type",
              "Yes"
            ],
            [
              "previousElementSibling",
              "Previous sibling element node",
              "No"
            ]
          ]
        }
      ],
      "examples": [
        {
          "title": "Traversing the DOM Tree Without Hardcoded Selectors",
          "description": "This example demonstrates DOM tree traversal using only relationship properties, without using getElementById or querySelector. This pattern is useful when writing event handlers or utility functions that need to navigate relative to an element they already have, such as finding the parent list when a list item is clicked.",
          "code_snippet": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>DOM Tree Traversal</title>\n  <style>\n    body  { font-family: sans-serif; max-width: 600px; margin: 2rem auto; padding: 0 1rem; }\n    li    { cursor: pointer; padding: 0.4rem 0.6rem; border-radius: 4px; }\n    li:hover  { background: #f1f5f9; }\n    li.active { background: #dbeafe; font-weight: 600; }\n    #info { background: #0f172a; color: #e2e8f0; padding: 1rem; border-radius: 8px;\n            font-family: monospace; font-size: 0.8rem; margin-top: 1rem; white-space: pre; }\n  </style>\n</head>\n<body>\n\n  <h2>Click any team member</h2>\n\n  <ul id=\"team\">\n    <li data-dept=\"frontend\">Priya Sharma</li>\n    <li data-dept=\"backend\">Rahul Gupta</li>\n    <li data-dept=\"devops\">Anjali Mehta</li>\n    <li data-dept=\"frontend\">Vikram Nair</li>\n  </ul>\n\n  <div id=\"info\">Click a name to inspect its tree position...</div>\n\n  <script>\n    const info = document.getElementById('info');\n    const team = document.getElementById('team');\n\n    // Event delegation: attach one listener to the parent instead of each li\n    team.addEventListener('click', (event) => {\n      const clicked = event.target;\n      if (clicked.tagName !== 'LI') return;\n\n      // Remove active from all siblings\n      [...team.children].forEach(li => li.classList.remove('active'));\n      clicked.classList.add('active');\n\n      // Navigate the tree using relationship properties\n      const parent     = clicked.parentElement;          // <ul id=\"team\">\n      const grandparent = clicked.parentElement          // <ul>\n                               .parentElement;           // <body>\n      const prev       = clicked.previousElementSibling; // li above, or null\n      const next       = clicked.nextElementSibling;     // li below, or null\n      const index      = [...parent.children].indexOf(clicked);\n      const total      = parent.children.length;\n\n      // childNodes vs children comparison on the parent\n      const allNodes    = parent.childNodes.length;      // includes text nodes\n      const elemNodes   = parent.children.length;        // element nodes only\n\n      info.textContent = [\n        `Clicked:          <${clicked.tagName.toLowerCase()}> \"${clicked.textContent}\"`,\n        `dept data attr:   ${clicked.dataset.dept}`,\n        `parentElement:    <${parent.tagName.toLowerCase()}#${parent.id}>`,\n        `grandparent:      <${grandparent.tagName.toLowerCase()}>`,\n        `position in list: ${index + 1} of ${total}`,\n        `prevElementSib:   ${prev ? '\"' + prev.textContent + '\"' : 'null (first item)'}`,\n        `nextElementSib:   ${next ? '\"' + next.textContent + '\"' : 'null (last item)'}`,\n        `parent.childNodes:  ${allNodes} (includes whitespace text nodes)`,\n        `parent.children:    ${elemNodes} (element nodes only)`,\n      ].join('\\n');\n    });\n  </script>\n\n</body>\n</html>",
          "output": "Page renders a four-item team list. Clicking any name highlights it blue and updates the info panel with: the element tag and text, the data attribute value, the parentElement, the grandparent element, the position in the list, the previous and next sibling names (or null for first and last), and a comparison showing that childNodes count is higher than children count because of whitespace text nodes.",
          "images": null,
          "video_url": null
        }
      ],
      "image_banner_url": null,
      "images": null,
      "video_url": null,
      "when_to_use": null,
      "when_to_avoid": null,
      "what_it_solves": null,
      "conceptual_understanding": [
        {
          "model": "The DOM tree is like a family tree. The document is the founding ancestor. Each element is a descendant. Parent, child, and sibling are literal relationship terms in this hierarchy. When you click a button and need to find its containing form, you walk up the family tree using parentElement until you reach the form ancestor."
        },
        {
          "model": "The difference between Node properties and Element properties is like counting everyone at a party versus counting only the guests on the invitation list. childNodes counts everyone: guests, staff, furniture (whitespace text nodes). children counts only the invited guests: actual HTML elements. For most UI work you want the guest list, not the full room count."
        }
      ],
      "common_mistakes": null,
      "bonus_tips": [
        {
          "tip": "Use the element.closest(selector) method to walk up the DOM tree and find the nearest ancestor matching a CSS selector. For example, inside a click handler on a delete button inside a card, event.target.closest('.card') finds the wrapping card element without knowing how many levels up it is. This is more reliable than a fixed chain of parentElement calls."
        }
      ],
      "related_topics": [
        "HTML DOM Fundamentals",
        "DOM Inspection and Manipulation Basics",
        "JavaScript Events"
      ],
      "is_active": true,
      "order_index": 1,
      "created_at": null,
      "updated_at": null
    },
    {
      "id": 2,
      "roadmap_id": 1,
      "technology_id": 1,
      "module_id": 2,
      "topic_id": 4,
      "slug": "dom-inspection-and-manipulation-basics",
      "title": "DOM Inspection and Manipulation Basics",
      "description": "DOM manipulation covers selecting elements to read, write, create, or remove nodes in the document.",
      "content": [
        {
          "type": "paragraph",
          "text": [
            {
              "value": "The DOM API provides four primary selection methods: "
            },
            {
              "value": "getElementById",
              "highlight": true
            },
            {
              "value": " for unique elements by ID, "
            },
            {
              "value": "querySelector",
              "highlight": true
            },
            {
              "value": " for the first CSS match, "
            },
            {
              "value": "querySelectorAll",
              "highlight": true
            },
            {
              "value": " for all CSS matches, and "
            },
            {
              "value": "getElementsByClassName",
              "highlight": true
            },
            {
              "value": " for a live collection by class. Once selected, content is read or written via "
            },
            {
              "value": "textContent",
              "highlight": true
            },
            {
              "value": " for plain text or "
            },
            {
              "value": "innerHTML",
              "highlight": true
            },
            {
              "value": " for HTML markup. Classes are managed via "
            },
            {
              "value": "classList",
              "highlight": true
            },
            {
              "value": " and attributes via "
            },
            {
              "value": "setAttribute",
              "highlight": true
            },
            {
              "value": " and "
            },
            {
              "value": "getAttribute",
              "highlight": true
            },
            {
              "value": ". Full API reference at "
            },
            {
              "value": "MDN: Document",
              "link": "https://developer.mozilla.org/en-US/docs/Web/API/Document"
            },
            {
              "value": "."
            }
          ]
        },
        {
          "type": "table",
          "headers": [
            "Operation",
            "Method or Property",
            "Returns",
            "Notes"
          ],
          "rows": [
            [
              "Select by ID",
              "getElementById('id')",
              "Element or null",
              "Fastest selection method"
            ],
            [
              "Select first match",
              "querySelector('css')",
              "Element or null",
              "Accepts any CSS selector"
            ],
            [
              "Select all matches",
              "querySelectorAll('css')",
              "Static NodeList",
              "Use spread [...] to get array methods"
            ],
            [
              "Select by class",
              "getElementsByClassName('cls')",
              "Live HTMLCollection",
              "Updates automatically as DOM changes"
            ],
            [
              "Read plain text",
              "element.textContent",
              "String",
              "Safe for reading user-supplied text"
            ],
            [
              "Write plain text",
              "element.textContent = '...'",
              "String set",
              "Never executes HTML, safe for user input"
            ],
            [
              "Read or write HTML",
              "element.innerHTML",
              "String",
              "Only use with trusted content, never user input"
            ],
            [
              "Add class",
              "classList.add('name')",
              "void",
              "Does not duplicate if already present"
            ],
            [
              "Remove class",
              "classList.remove('name')",
              "void",
              "Silent if class not present"
            ],
            [
              "Toggle class",
              "classList.toggle('name')",
              "Boolean",
              "Returns true if class was added"
            ],
            [
              "Get attribute",
              "getAttribute('name')",
              "String or null",
              "Works for all attributes including data-*"
            ],
            [
              "Set attribute",
              "setAttribute('name','val')",
              "void",
              "Creates attribute if it does not exist"
            ],
            [
              "Create element",
              "createElement('tag')",
              "Element",
              "Element is detached until inserted"
            ],
            [
              "Append child",
              "parent.appendChild(el)",
              "Element",
              "Inserts at end of parent"
            ],
            [
              "Remove element",
              "element.remove()",
              "void",
              "Modern, removes itself from DOM"
            ]
          ]
        }
      ],
      "examples": [
        {
          "title": "Selection Methods Compared and Safe Content Manipulation",
          "description": "This example puts all four selection methods side by side and demonstrates the critical difference between textContent and innerHTML for writing content. It also shows the complete workflow for creating a new element, setting its content safely, and inserting it at a specific position in the DOM.",
          "code_snippet": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Selection and Manipulation</title>\n  <style>\n    body { font-family: sans-serif; max-width: 700px; margin: 2rem auto; padding: 0 1rem; }\n    .item { padding: 0.5rem 0.75rem; border: 1px solid #e5e7eb;\n            border-radius: 6px; margin-bottom: 0.4rem; }\n    .highlight { background: #fef9c3; border-color: #ca8a04; }\n    .error     { background: #fef2f2; border-color: #dc2626; color: #dc2626; }\n    .success   { background: #f0fdf4; border-color: #16a34a; }\n    button { padding:0.4rem 0.8rem; border-radius:6px;\n             border:1px solid #d1d5db; cursor:pointer; margin:0.25rem; }\n    #log { background:#0f172a; color:#86efac; padding:1rem; border-radius:8px;\n           font-family:monospace; font-size:0.8rem; margin-top:1rem; white-space:pre-wrap; }\n    input { padding:0.4rem 0.6rem; border:1px solid #d1d5db;\n            border-radius:6px; width: 200px; }\n  </style>\n</head>\n<body>\n\n  <h2>Notification List</h2>\n\n  <div id=\"notif-list\">\n    <div class=\"item\" id=\"notif-1\">Server deployment completed successfully.</div>\n    <div class=\"item highlight\" id=\"notif-2\">Memory usage above 80% threshold.</div>\n    <div class=\"item\" id=\"notif-3\">Backup job scheduled for midnight.</div>\n  </div>\n\n\n  <!-- textContent vs innerHTML safety demo -->\n  <h2>Content Writing Safety</h2>\n  <div id=\"safe-demo\" class=\"item\">\n    Original content here.\n  </div>\n\n  <div style=\"margin-bottom:0.5rem;\">\n    <input id=\"user-input\" type=\"text\"\n           value=\"<img src=x onerror=alert('XSS')>\">\n    <button id=\"btn-text\">Write via textContent</button>\n    <button id=\"btn-html\">Write via innerHTML</button>\n  </div>\n\n\n  <div>\n    <button id=\"btn-select\">Compare selectors</button>\n    <button id=\"btn-add-success\">Add success notif</button>\n    <button id=\"btn-add-error\">Add error notif</button>\n    <button id=\"btn-remove\">Remove first notif</button>\n    <button id=\"btn-clear\">Clear all</button>\n  </div>\n\n  <div id=\"log\">Click a button...</div>\n\n\n  <script>\n    const list = document.getElementById('notif-list');\n    const log  = document.getElementById('log');\n    let   counter = 4;\n\n\n    // ===== SELECTION METHODS COMPARED =====\n    document.getElementById('btn-select').onclick = () => {\n\n      // 1. getElementById: fastest, returns single element or null\n      const byId = document.getElementById('notif-2');\n\n      // 2. querySelector: first CSS match\n      const first = document.querySelector('#notif-list .item');\n\n      // 3. querySelectorAll: all CSS matches, static NodeList\n      const all = document.querySelectorAll('#notif-list .item');\n\n      // 4. getElementsByClassName: live HTMLCollection (updates as DOM changes)\n      const live = document.getElementsByClassName('highlight');\n\n      log.textContent = [\n        `getElementById('notif-2'):       \"${byId.textContent.trim().slice(0,30)}...\"`,\n        `querySelector('.item'):          \"${first.textContent.trim().slice(0,30)}...\"`,\n        `querySelectorAll('.item').length: ${all.length}`,\n        `getElementsByClassName length:   ${live.length} (live, auto-updates)`,\n      ].join('\\n');\n    };\n\n\n    // ===== textContent vs innerHTML SAFETY =====\n    document.getElementById('btn-text').onclick = () => {\n      const demo  = document.getElementById('safe-demo');\n      const input = document.getElementById('user-input').value;\n\n      // SAFE: textContent treats value as plain text\n      // The <img onerror=...> is rendered as visible text, not executed\n      demo.textContent = input;\n      demo.className = 'item success';\n      log.textContent = 'Set via textContent.\\nHTML tags are escaped and shown as text.\\nNo script executed.';\n    };\n\n    document.getElementById('btn-html').onclick = () => {\n      const demo  = document.getElementById('safe-demo');\n      const input = document.getElementById('user-input').value;\n\n      // DANGEROUS with user input: innerHTML parses and executes HTML\n      // The onerror attribute on the broken img fires as JavaScript\n      // For demonstration only - do NOT use innerHTML with user input in production\n      demo.innerHTML = '<strong>[innerHTML output]:</strong> ' + input;\n      demo.className = 'item error';\n      log.textContent = 'WARNING: innerHTML executed the user input as HTML.\\nIn production this triggers XSS attacks.\\nAlways use textContent for user-supplied text.';\n    };\n\n\n    // ===== CREATE AND INSERT =====\n    function addNotif(text, type) {\n      const div = document.createElement('div');\n      div.className = `item ${type}`;\n      div.id = `notif-${counter++}`;\n      div.textContent = text;        // textContent is safe even here\n      list.appendChild(div);\n      log.textContent = `Created ${div.id} and appended to list.`;\n    }\n\n    document.getElementById('btn-add-success').onclick = () =>\n      addNotif('Deployment pipeline passed all checks.', 'success');\n\n    document.getElementById('btn-add-error').onclick = () =>\n      addNotif('Database connection timeout on replica.', 'error');\n\n\n    // ===== REMOVE =====\n    document.getElementById('btn-remove').onclick = () => {\n      const first = list.firstElementChild;\n      if (first) {\n        const id = first.id;\n        first.remove();\n        log.textContent = `Removed ${id}.`;\n      } else {\n        log.textContent = 'List is empty.';\n      }\n    };\n\n    document.getElementById('btn-clear').onclick = () => {\n      // Clear all children efficiently\n      list.innerHTML = '';  // safe here: no user input involved\n      log.textContent = 'All notifications cleared.';\n    };\n\n  </script>\n\n</body>\n</html>",
          "output": "Page renders three notification items (second highlighted yellow), a content safety demo area with a pre-filled input containing an XSS payload, and action buttons. Clicking Compare selectors logs all four selection methods and their results. Clicking Write via textContent renders the XSS payload as safe escaped text. Clicking Write via innerHTML executes the payload and triggers a browser alert. Add buttons append styled success or error notifications. Remove deletes the first item. Clear empties the list.",
          "images": null,
          "video_url": null
        }
      ],
      "image_banner_url": null,
      "images": null,
      "video_url": null,
      "when_to_use": null,
      "when_to_avoid": null,
      "what_it_solves": null,
      "conceptual_understanding": [
        {
          "model": "DOM selection methods are like different ways to find a person in a building. getElementById is knowing the exact room number: direct, fastest. querySelector is describing the person: find the first person wearing a blue badge in the east wing. querySelectorAll is finding everyone matching that description. getElementsByClassName is a live employee directory that updates the moment someone joins or leaves."
        },
        {
          "model": "textContent versus innerHTML is the difference between a typewriter and a printing press. textContent types out whatever you give it as plain characters. The angle brackets in a script tag become visible less-than and greater-than symbols, harmless on screen. innerHTML runs the printing press: it formats and executes everything it receives as real HTML markup, which is powerful for trusted content but dangerous for anything a user typed."
        }
      ],
      "common_mistakes": null,
      "bonus_tips": [
        {
          "tip": "Spread a NodeList from querySelectorAll into an array using [...document.querySelectorAll('selector')] to unlock array methods like map, filter, and reduce. NodeList only has forEach natively. Converting to a real array lets you chain operations: [...document.querySelectorAll('.card')].filter(c => c.dataset.inStock === 'true').map(c => c.dataset.price) returns all prices for in-stock cards in one expression."
        }
      ],
      "related_topics": [
        "HTML DOM Fundamentals",
        "DOM Tree and Node Relationships",
        "JavaScript Events"
      ],
      "is_active": true,
      "order_index": 2,
      "created_at": null,
      "updated_at": null
    }
  ],
  "seo_metadata": {
    "meta_title": "HTML DOM Fundamentals | Tree, Nodes, Selection and Manipulation Guide",
    "meta_description": "Learn HTML DOM fundamentals: the DOM tree, node types, parent-child relationships, selection methods, content manipulation, and creating or removing elements.",
    "keywords": [
      "HTML DOM",
      "DOM tree",
      "DOM node types",
      "DOM manipulation",
      "querySelector",
      "getElementById",
      "DOM parent child",
      "childNodes vs children",
      "textContent vs innerHTML",
      "DOM traversal"
    ],
    "canonical_url": "/html/html-dom-fundamentals",
    "robots": "index, follow"
  }
}